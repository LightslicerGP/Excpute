r0 = 0
r1 = 1
r2 = 2
r3 = 3
r4 = 4
r5 = 5
r6 = 6
r7 = 7

r_x = 0
r_y = 1
r_error = 2
r_e2 = 3

rSP = 5
rFlags = 6
rPC = 7

r_col = 0
g_col = 1
b_col = 2
x_coord = 3
y_coord = 4
set_px = 5
fill_display = 6
push_buffer = 7

on = 255
off = 0

#x0 = 0
#y0 = 15
#x1 = 12
#y1 = 17

x0 = 0
y0 = 0
x1 = 12
y1 = 200

init:

loop:
    cal bresenham_init # 0
    # spd push_buffer
    jmp loop # 1



bresenham_init:
    ldi r1 on # 2
    spd r1 r_col # 3
    spd r1 g_col # 4
    spd r1 b_col # 5

    ldi r_x x0
    ldi r_y y0

    ldi r2 x1               # figuring out dx
    sub r2 r_x r2           # x1 - x0
    ldi r3 0b10000000       # 10: filter for negative bit
    and r2 r3 r2            # store filtered num in r3
    xor r2 r3 r2            # compare
    jiz r2 abs_x            # jump if negative
    ldi r2 x1               # if not, keep as is
    sub r2 r_x r2           # get x1-x0
abs_x_done:                 # r2 has dx
    ldi r3 0                # memory address that will store dx
    str r2 r3               # store dx (r2) in memory address (r3, 0)

    ldi r2 y1               # figuring out dy
    sub r2 r_y r2           # y1 - y0
    ldi r3 0b10000000       # 20: filter for negative bit
    and r2 r3 r2            # store filtered num in r3
    xor r2 r3 r2            # compare
    jiz r2 abs_y            # jump if negative
    ldi r2 y1               # if not, keep as is
    sub r2 r_y r2           # get y1-y0
abs_y_done:                 # r2 has dy
    ldi r3 1                # memory address that will store dy
    str r2 r3               # store dy (r2) in memory address (r3, 1)

    # mem adr 0 has dx, mem adr 1 has dy

    ldi r2 x1               # we wanna do (x0 < x1) ? 1 : -1 for sx
    cmp r_x r2              # compare A (r_x, x0) and B (r2, x1)
    ldi r3 0b00001000       # 30: check negative
    and r3 rFlags rFlags
    xor r3 rFlags r3        # store compare result in r3
    jiz r3 set_sx           # set sx to 1
    ldi r2 -1               # set sx -1
set_sx_done:                # r2 has sx
    ldi r3 2                # memory address that will store sx
    str r2 r3               # store sx (r2) in memory address (r3, 2)

    ldi r2 y1               # we wanna do (y0 < y1) ? 1 : -1 for sy
    cmp r_y r2              # compare A (r_y, y0) and B (r2, y1)
    ldi r3 0b00001000       # check negative
    and r3 rFlags rFlags    # 40:
    xor r3 rFlags r3        # store compare result in r3
    jiz r3 set_sy           # set sy to 1
    ldi r2 -1               # set sy -1
set_sy_done:                # r2 has sy
    ldi r3 3                # memory address that will store sy
    str r2 r3               # store sy (r2) in memory address (r3, 3)
    
    # mem adr 2 has sx, mem adr 3 has sy

    ldi r2 0          # calculating error
    lod r2 r2         # r2 has dx
    ldi r3 1
    lod r3 r3         # r3 has dy

    sub r2 r3 r_error # 50: store err in reg 2


bresenham:
    spd r0 x_coord
    spd r1 y_coord
    spd set_px
    spd push_buffer

    ldi r3 x1
    xor r0 r3 r3
    jiz r3 exit_bresenham_x # x0==x1 passed, check y
exit_fail:
    lsh r_error r_e2  # stores 2 * err in r_e2 (r3)

    ldi r4 1          # get dy adr
    lod r4 r4         # 60: get dy value
    inv r4            # invert
    inc r4            # add one

    # r4 has -dy

    cmp r_e2 r4 # comparing for e2 > -dy
    ldi r4 0b00000001 # filter for carry
    and r4 rFlags rFlags
    xor r4 rFlags r4
    jiz r4 update_x # e2 > -dy
update_x_done: # continue

    ldi r4 0          # get dx adr
    lod r4 r4         # get dx value
    
    # r4 has dx

    cmp r_e2 r4       # 70: comparing for e2 < dx
    ldi r4 0b00001000 # filter for negative
    and r4 rFlags rFlags
    xor r4 rFlags r4
    jiz r4 update_y   # e2 < dx
update_y_done: # continue
    jmp bresenham


abs_x:                # 2s compliment
    ldi r2 x1
    sub r2 r_x r2     # get x1-x0
    inv r2            # invert
    inc r2            # add 1
    jmp abs_x_done    # 80: r2 has |x1 - x0|

abs_y:                # 2s compliment
    ldi r2 y1
    sub r2 r_y r2     # get y1-y0
    inv r2            # invert
    inc r2            # add 1
    jmp abs_y_done    # r2 has |y1 - y0|


set_sx:
    ldi r2 1
    jmp set_sx_done

set_sy:
    ldi r2 1
    jmp set_sy_done


update_x:
    ldi r4 1          # 90: get dy adr
    lod r4 r4         # get dy value
    sub r_error r4 r_error

    ldi r4 2          # get sx adr
    lod r4 r4         # get sx value
    add r_x r4 r_x

    jmp update_x_done
    
update_y:
    ldi r4 0          # get dx adr
    lod r4 r4         # get dx value
    add r_error r4 r_error

    ldi r4 3          # 100: get sy adr
    lod r4 r4         # get sy value
    add r_y r4 r_y

    jmp update_y_done

exit_bresenham_x:
    ldi r3 y1
    xor r1 r3 r3
    jiz r3 exit_bresenham # y0==y1 passed, exit
    jmp exit_fail # didnt pass, go back

exit_bresenham:
    rtn # 108